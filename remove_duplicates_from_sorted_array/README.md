# Remove Duplicates from Sorted Array

[link](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)

## 概要

整数配列 nums が非減少順にソートされているとき、重複をその場で削除し、各ユニークな要素が一度だけ現れるようにします。要素の相対的な順序は維持されるべきです。その後、nums のユニークな要素の数を返します。

nums のユニークな要素の数を k と考えます。受け入れられるためには、以下のことを行う必要があります：

nums 配列を変更し、最初の k 要素が最初に nums に存在した順序でユニークな要素を含むようにします。残りの nums の要素は重要ではありません。
k を返します。

## ジャッジ方法

ジャッジは以下のコードであなたのソリューションをテストします：

```java
コードをコピーする
int[] nums = [...]; // 入力配列
int[] expectedNums = [...]; // 正しい長さの期待される答え

int k = removeDuplicates(nums); // あなたの実装を呼び出す

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
```

全てのアサーションが通れば、あなたのソリューションは受け入れられます。

## 例1

- 入力: nums = [1,1,2]
- 出力: 2, nums = [1,2,_]
- 説明: あなたの関数は k = 2 を返すべきで、nums の最初の2つの要素はそれぞれ 1 と 2 です。それ以降の要素は重要ではありません（したがって、アンダースコアで示されています）。

## 例2

- 入力: nums = [0,0,1,1,1,2,2,3,3,4]
- 出力: 5, nums = [0,1,2,3,4,_,_,_,_,_]
- 説明: あなたの関数は k = 5 を返すべきで、nums の最初の5つの要素はそれぞれ 0, 1, 2, 3, 4 です。それ以降の要素は重要ではありません（したがって、アンダースコアで示されています）。

## 制約

- nums.length は 1 以上 3 * 10^4 以下である。
- nums[i] は -100 以上 100 以下である。

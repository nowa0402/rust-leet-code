# Remove Element

整数配列 nums と整数 val が与えられたとき、nums 内の val のすべての出現をその場で削除します。要素の順序は変更されても構いません。その後、val と等しくない nums の要素の数を返します。

val と等しくない nums の要素数を k と仮定します。問題が受け入れられるためには、次のことを行う必要があります。

配列 nums を変更して、最初の k 個の要素が val と等しくない要素を含むようにします。残りの nums の要素や nums のサイズは重要ではありません。
k を返します。

## カスタムジャッジ

```cpp
int[] nums = [...]; // 入力配列
int val = ...; // 削除する値
int[] expectedNums = [...]; // 正しい長さの期待される答え。値は val と等しくないようにソートされている。

int k = removeElement(nums, val); // あなたの実装を呼び出す

assert k == expectedNums.length;
sort(nums, 0, k); // nums の最初の k 要素をソートする
for (int i = 0; i < actualLength; i++) {
    assert nums[i] == expectedNums[i];
}
```

## 例1

- 入力: nums = [3,2,2,3], val = 3
- 出力: 2, nums = [2,2,_,_]
- 説明: 関数は k = 2 を返すべきで、最初の二つの要素は 2 であるべきです。k の後の要素は何でも構いません（そのためアンダースコアで示されています）。

## 例2

- 入力: nums = [0,1,2,2,3,0,4,2], val = 2
- 出力: 5, nums = [0,1,4,0,3,_,_,_]
- 説明: 関数は k = 5 を返すべきで、最初の五つの要素は 0, 0, 1, 3, 4 を含むべきです。五つの要素は任意の順序で返されても構いません。k の後の要素は何でも構いません（そのためアンダースコアで示されています）。

## 制約

- 0 <= nums.length <= 100
- 0 <= nums[i] <= 50
- 0 <= val <= 100
